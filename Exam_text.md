# Web Applications I 2024/25 – Exam \#1 (deadline 2025-06-19 at 23:59)

# “Stuff Happens”

## FINAL  VERSION

Design and implement a web application for playing a single-player version of the board game “Stuff Happens”.

In the game, each player must play against the computer (the web application, in our case) to get a total of 6 cards, each representing a horrible situation, according to the rules described below.

The game is based on an archive of at least **50 cards with horrible situations** (from “your swimsuit slips off in a public pool” to “a shark attacks you and you lose a leg”). Each card contains the *name of the situation*, a representative *image*, and a *bad luck index* from 1 to 100 (where 1 is “nothing serious” and 100 is “but why me?”). Each card has a unique bad luck index, with a difference between each index of at least 0.5. Each student must choose, for their project, a field of life as the theme of the cards to be used in the game (for example, university life, sports and fitness, love life, travel and tourism, etc.).

The application allows you to play multiple games. The game starts with a player receiving 3 random cards (generated by the server and immediately visible to the player) and takes place over multiple rounds. Each round offers a new horrible situation, as follows:

1. The player sees the name and image (but not the bad luck index\!) of the horrible situation assigned to him/her, different from those present in his/her cards and also randomly generated by the server. The player, being able to see all the cards in his/her possession with all their details, ordered by increasing values of the bad luck index, must indicate where the received situation should be placed, as a bad luck index, among the cards in his/her possession. For example, if the player had cards with index 1.5, 42.5 and 99, he/she could assume that the assigned situation has a bad luck index between 42.5 and 99 and therefore place it between the second and the third cards.  
2. If the player guesses the correct location within 30 seconds, he or she gets the card for that situation, which is then added to the player's pool of cards, and all information about the card is displayed.  
3. If the player does not guess the correct location within 30 seconds or the time expires without the player making a choice, he or she does not get the card (and does not see any information on that card). That card is discarded and must not be presented again in subsequent rounds of the same game.   
4. When a round is won or lost, the application displays an appropriate message and asks the player to confirm when he or she is ready to start a new round.   
5. The game ends when the player has 6 cards in his or her possession (wins) or has not guessed the correct location of three horrible situations (loses). 

**Registered users** (i.e., after logging in) will play a game until it is completed (won or lost). In addition, all their completed games will be listed in a history visible on the user profile page, ordered by date. The history must show, for each game, the names of the horrible situations of the cards involved in the game (including the ones received at the beginning of the game), with an indication of whether they were won or not and in which round, and the outcome of the game itself with the total number of collected cards. The cards received at the start of the game won’t be linked to any specific round.

**Anonymous users** (i.e., visitors to the site), on the other hand, can view the game instructions and play only demo games lasting a single round (only one card to play, starting from the initial 3 cards). They will not have access to any of the registered user features.

At the end of the game, a summary is displayed showing all the cards won by the player (name of the horrible situation, image and its bad luck index) and the player can choose to start a new game.

The organization of these specifications in different screens (and possibly on different routes) is left to the student.

## Project requirements

* The application architecture and source code must be developed by adopting the best practices in software development, in particular, those relevant to single-page applications (SPA) using React and HTTP APIs. APIs should be carefully protected and the front-end should not receive unnecessary information.  
* The application should be designed for a desktop browser. Responsiveness for mobile devices is not required nor evaluated.  
* The project must be implemented as a React 19 application that interacts with an HTTP API implemented in Node+Express. The Node version must be the one used during the course (22.x, LTS). The database must be stored in a SQLite file. The programming language must be JavaScript.  
* The communication between client and server must follow the “two servers” pattern, by properly configuring CORS, and React must run in “development” mode with Strict Mode activated.  
* The evaluation of the project will be carried out by navigating the application. Neither the behavior of the “refresh” button, nor the manual entering of a URL (except /) will be tested, and their behavior is undefined. Also, the application should never “reload” itself as a consequence of normal user operations.  
* The root directory of the project must contain a README.md file and have two subdirectories (client and server). The project must be started by running the two commands: “cd server; nodemon index.mjs” and “cd client; npm run dev”. A template for the project directories is already available in the exam repository. You may assume that nodemon is globally installed. No other global modules will be available.  
* The whole project must be submitted on GitHub, on the same repository created by GitHub Classroom.  
* The project **must not include** the node\_modules directories. They will be re-created by running the “npm install” command right after “git clone”.  
* The project may use popular and commonly adopted libraries (for example, day.js, react-bootstrap, etc.), if applicable and useful. All required libraries must be correctly declared in the package.json file, so that the npm install command might install them.  
* User authentication (login and logout) and API access must be implemented with Passport.js and session cookies. The credentials should be stored in an encrypted and salted form. The user registration procedure is not requested nor evaluated.

## Quality requirements

In addition to the implementation of the required application functionality, the following quality requirements will be evaluated:

* Database design and organization.  
* Design of the HTTP APIs.  
* Organization of React components and routes.  
* Correct usage of React patterns (functional behavior, hooks, state, context, and effects). Avoiding direct manipulation of the DOM is included in these rules.  
* Code clarity.  
* Absence of errors (and warnings) in the client console (except those caused by errors in the imported libraries).  
* Absence of application crashes or unhandled exceptions.  
* Essential data validation (in Express and React).  
* Basic usability and user-friendliness.  
* Originality of the solution.

## Database requirements

* The project database must be realized by the student and must be preloaded with at least 50 cards of horrible situations that may happen in the chosen field of life. It should contain at least 2 registered users, and one of them must already have played and won some games.

## Contents of the README.md file

The README.md file must contain the following information (a template is available in the project repository). Generally, each information item should take no more than 1-2 lines.

1. Server-side:  
   1. A list of the HTTP APIs offered by the server, with a short description of the parameters and the exchanged objects.  
   2. A list of the database tables, with their purpose.  
2. Client-side:  
   1. A list of ‘routes’ for the React application, with a short description of the purpose of each route.  
   2. A list of the main React components.  
3. Overall:  
   1. Two screenshots of the **application, one with the user history and the other during a game**, respectively. The screenshots must be embedded in the README by linking two images committed in the repository.  
   2. Usernames and passwords of the registered users.

## Submission procedure

To correctly submit the project, you must:

* **Be enrolled** in the exam call.  
* Use the provided **link** to **join the classroom** on GitHub Classroom (i.e., correctly **associate** your GitHub username with your student ID) and **accept the assignment**.  
* **Push the project** into the **main branch **of the repository created for you by GitHub Classroom. The last commit (the one you wish to be evaluated) must be **tagged** with the tag **final** (note: final is all-lowercase with no spaces, and it is a git ‘tag’, nor a ‘commit message’).

Note: to tag a commit, you may use (from the terminal) the following commands:

\# ensure the latest version is committed  
git commit \-m "...comment..."  
git push 

\# add the 'final' tag and push it  
**git tag final**  
**git push origin \--tags**

Alternatively, you may insert the tag from GitHub’s web interface (follow the link ‘Create a new release’).

To test your submission, these are the exact commands that the teachers will use to download and run the project. You may wish to test them on a clean directory:

git clone *...yourCloneURL...*  
cd *...yourProjectDir...*  
git pull origin main  \# just in case the default branch is not main   
git checkout \-b evaluation final \# check out the version tagged with 'final' and create a new branch 'evaluation'  
(cd client ; npm install; npm run dev)  
(cd server ; npm install; nodemon index.mjs)

Ensure that all the needed packages are downloaded by the npm install commands. Be careful: if some packages are installed globally on your computer, they might not be listed as dependencies. Always check it in a clean installation.

Be aware that Linux is case-sensitive for file names, while Windows and macOS are not. Double-check the case of import statements and all file names.

